## CLI tool to demonstrate how to deploy and interact with Solidity smart contract on Ethereum.

The main objective of the project is to store proof of existence of a media file on chain.
As it is not feasible to store actual media files or documents on chain due to high cost associated with storage
we can store file metadata on chain and use that to check file integrity later.

Functionality:
- create Ethereum wallet
- check balance of Ethereum wallet
- deploy smart contract
- show status of smart contract
- add media metadata (proof) to smart contract
- verify media metadata on chain

CLI commands are grouped as follows:
- wallet
  - create
  - balance
- contract
  - deploy
  - status
- file
  - add
  - verify

## Solidity Smart Contract.
You will find a contract in ```Store.sol``` file. It's a basic smart contract for adding and retrieving values from a map.  
The bindings for Go were generated using [Solidity compiler](https://docs.soliditylang.org/en/v0.8.9/installing-solidity.html) 
and [abigen](https://geth.ethereum.org/docs/tools/abigen):
```shell
solc Store.sol --combined-json abi,bin | abigen --pkg=main --type=storage --out=store.go --combined-json - 
 ```

Smart contract mapping to store media metadata.
```solidity
 mapping(bytes16 => mediaFile) private mediaFiles;
```
A map key in our case is a UUID.v5 which is generated deterministically based on the name of the file. We therefore assume that
in our scenario media files we are handling have unique names.
Map value is a simple object with a name, hash and a date.  
```solidity
struct mediaFile {
    bytes name;
    bytes32 hash;
    uint32 created;
}
```
Name is base64 encoded base file name.  
The hash is a sha256 hashsum of the file.  
Date represents when the file was processed.  

The main functions of the contract are ```add``` and ```get```.
```solidity
function add(bytes16 key, bytes memory name, bytes32 hash, uint32 created) public onlyOwner {
    mediaFiles[key] = mediaFile(name, hash, created);
    mapSize++;
}

function get(bytes16 key) public view returns (bytes memory, bytes32, uint32) {
    mediaFile memory file = mediaFiles[key];
    return (file.name, file.hash, file.created);
}
```

The contract contains a single modifier to ensure that only a contract owner can invoke certain functions.
```solidity
modifier onlyOwner {
    require(msg.sender == _owner, "only the owner can call this function");
    _;
}
```

It is possible to change owner of the contract by passing an address of a new owner.
```solidity
function changeOwner(address newOwner) public onlyOwner {
    _owner = newOwner;
}
```


## Requirements.
1. To run CLI you can use your existing wallet and private key or use ```wallet create``` to create one.
2. That wallet should have sufficient amount of funds to pay for fees when deploying a contract.
3. Most commands require a ```node_url``` which is a URL of json-rpc node. You can use [Infura](https://www.infura.io/) and create API key
for either a mainnet or testnet.
4.

## Important note.
It's critically important to securely store a private key generated by ```wallet create``` command.
Ideally private key should be stored in a file or environment variable.

## Future work.
1. This CLI could be extended to upload a file to [IPFS](https://ipfs.tech/) distributed storage or Cloud storage
and file location URL could be stored in media metadata struct in Solidity.
2. Change CLI to API and add a simple Web interface for adding/verifying files.

### Examples.

### create a wallet
Only required if you don't already have an Ethereum wallet or want to create a new one just for testing. Remember that new wallet
will have to be funded. Use Sepolia testnet and get some test coins from one of many online faucets available.  
```shell

```

### check wallet balance
```shell

```

### deploy a contract
```shell

```

### check the status of a deployed contract
```shell

```

### add media file
```shell

```

### check the status of a deployed contract 
```shell

```

### verify media file
```shell

```